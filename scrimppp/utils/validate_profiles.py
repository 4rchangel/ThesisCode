import argparse
import os
import re
import subprocess
from copy import deepcopy

# "backporting" for the sake of python 3.4.1 in lrz python 3.5 module...
# source: https://stackoverflow.com/questions/40590192/getting-an-error-attributeerror-module-object-has-no-attribute-run-while
def run(*popenargs, input=None, check=False, **kwargs):
    if input is not None:
        if 'stdin' in kwargs:
            raise ValueError('stdin and input arguments may not both be used.')
        kwargs['stdin'] = subprocess.PIPE

    process = subprocess.Popen(*popenargs, **kwargs)
    try:
        stdout, stderr = process.communicate(input)
    except:
        process.kill()
        process.wait()
        raise
    retcode = process.poll()
    if check and retcode:
        raise subprocess.CalledProcessError(
            retcode, process.args, output=stdout, stderr=stderr)
    return retcode, stdout, stderr

parser = argparse.ArgumentParser()
parser.add_argument("folder", metavar="DIRECTORY", type=str, nargs=1, help='directory with a set of matrix profiles generated by a validation job')
parser.add_argument('--cvt_prof_path', type=str, nargs=1, help='full path of a profile conversion utility. If not specified it is assumed to be in the cwd or not required')
parser.add_argument('--force_orig_baseline', action='store_true', help='raise a failure, if no profile produced by the original algorithm is available for comparision')

args = parser.parse_args()

# get a path to the conversion utitlty
if not args.cvt_prof_path or not len(args.cvt_prof_path) > 0:
    cvt_path = './cvt_matprof bin-to-ascii'
else:
    cvt_path =args.cvt_prof_path[0]
require_orig_baseline = args.force_orig_baseline


# retrieve the list of files
folder = args.folder[0]
if not os.path.isdir(folder):
    print("specified folder not existing, aborting")
    exit(1)
print("operating on folder: " + str(folder))
files = os.listdir(folder)

# retrieve a set with all (data-id, profile-length, window-length combinations) combinations
def get_exp_params(filename):
    match = re.match('matprof_v([\d]+)_l([\d]+)m([\d]+)', filename)
    if not match:
        raise RuntimeError("matrix profile filename does not match the validation job pattern")
    return ( int(match.group(1)), int(match.group(2)), int(match.group(3)) )

#print( get_exp_params(files[0]))
experiments = set( map(lambda fname: get_exp_params(fname), files)  )

def get_baseline(filelist, orig_only=True):
    algo_orig_files = list(filter(lambda fname: re.search("alg#scrimppp_orig#", fname), filelist))
    if len(algo_orig_files) > 0:
        return algo_orig_files[0]
    if orig_only:
        return None # if only the original variant is allowed as a baseline, we are done here...
    alg_sequ_files = list(filter(lambda fname: re.search("alg#scrimp_sequ#", fname), filelist))
    if len(alg_sequ_files) > 0:
        print( "no original algo run found, comparing to scrimp_sequ version" )
        return alg_sequ_files[0]
    else:
        return None

def gen_cmp_pairs(filelist, baseline=None):
    cmp_list = []
    if baseline:
        for file in filelist:
            if file != baseline:
                cmp_list.append( (baseline, file) )
    else:
        for i in range(1, len(filelist)):
            cmp_list.append( (filelist[i-1], filelist[i]) )

    return cmp_list

def parse_proc_num(filename):
    matchobj = re.search(r'_p(\d+)_', filename)
    if not matchobj:
        raise RuntimeError('Unable to retrieve number of processors')
    return int(matchobj.group(1))

def get_proc_set(file_list):
    procs = set(map(lambda fname: parse_proc_num(fname), file_list))
    return procs

def parse_algo(fname):
    matchobj = re.search(r'alg#(\S+)#', fname)
    if not matchobj:
        raise('could not parse algorithm name from the file')
    return matchobj.group(1)

def get_algo_set(file_list):
    algos = set(map(lambda fname: parse_algo(fname), file_list))
    return algos

def get_config_str(config):
    return "data-id %d, time-series length %d, window-length %d"%config

max_prof_diff = 0.0
num_cmps = 0
for exp in experiments:
    exp_files = list(filter(lambda fname: get_exp_params(fname) == exp, files))
    print("Processing set of result files with the configuration: " + get_config_str(exp))
    if len(exp_files) < 2:
        raise RuntimeError("profile %s can not be compared to any other profile, as none with the same configuration (%s) is existing..."%(exp_files[0], get_config_str(exp)) )

    baseline = get_baseline(exp_files, require_orig_baseline )
    if baseline:
        cmp_list = gen_cmp_pairs(exp_files, baseline)
        print("using %s as a basline")
    elif not require_orig_baseline:
        cmp_list = gen_cmp_pairs(exp_files)
        print("no sequential baseline for config. Doing pairwise comparisions")
    else:
        print("VALIDATION FAILED: no required baseline from original algorithm for configuration " + get_config_str(exp))
        exit(1)
    #print(cmp_list)

    # perform the pairwise comparisions of the matrix profiles
    scriptdir= os.path.dirname(os.path.realpath(__file__))
    cmpscript= os.path.join(scriptdir, 'compare_profile_indices.py')
    for filepair in cmp_list:
        file1 = os.path.join(folder, filepair[0])
        file2 = os.path.join(folder, filepair[1])
        print('comparing profiles %s and %s'%(file1, file2))
        # python 3.5 style:
        # proc_result = subprocess.run(['python3', cmpscript, file1, file2, '--cvt_prof_path',  cvt_path, '--silent'], stdout=subprocess.PIPE)
        # cmplog = proc_result.stdout.decode('utf-8')
        # success_ind = re.search(r'SUCCESS: The profile indices coincide', cmplog)
        # if proc_result.returncode != 0 or not success_ind:
        retcode, stdout, stderr = run(['python3', cmpscript, file1, file2, '--cvt_prof_path',  cvt_path, '--silent'], stdout=subprocess.PIPE)
        cmplog = stdout.decode('utf-8')
        success_ind = re.search(r'SUCCESS: The profile indices coincide', cmplog)
        if retcode != 0 or not success_ind:
            raise RuntimeError('COMPARISION FAILED: comparing the profiles %s and %s failed.'%(filepair))
        else:
            # retrieve the difference in the profile values

            diffmatch = re.search(r'difference in profile values: (\d+?.\d+?(?:e[+-]\d+))', cmplog)
            # print the log with some indentation
            cmplog = re.sub(r'^', r'    ', cmplog, re.MULTILINE) # for some reason replacing '^' with '   ' with re.MULTILINE worked only on the first line. Just solve it by replaing \n too
            cmplog = re.sub(r'\n', r'\n    ', cmplog)
            print(cmplog)
            if not diffmatch:
                raise RuntimeError("Failed to parse the profile difference value")
            delta = float(diffmatch.group(1))
            if (delta > max_prof_diff):
                max_prof_diff = delta
            num_cmps += 1
    print("Finished processing configuration: " + get_config_str(exp))
    print("..........................................................\n")


print ("-----------------------------------------------------------")
print ("VALIDATION SUCCESSFULL, SUMMARY:")
print ("All profile indices coincide")
print ("Overall maximum difference in profile values {:.3E}".format(max_prof_diff) )
print ("compared %d pairs of matrix profile result files"%num_cmps)
print ("total number of result files used: %d"%len(files))
print ("number of different experiments (groups with same profile): %d"%len(experiments))
print ("Various algorithms encountered: " + str(list(get_algo_set(files))) )
print ("Various numbers of workers used for profile generation: " + str(list(get_proc_set(files))) )
print ("Various time series lengths used: " + str(list(set(map(lambda cfg: cfg[1], experiments)))))
print ("various window length used: " + str(list(set(map(lambda cfg: cfg[2], experiments)))))




